<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Shape Wars - Polished Edition</title>
<style>
  body {
    margin: 0;
    background: radial-gradient(circle at center, #0a1a2a 0%, #050c18 100%);
    overflow: hidden;
  }
  canvas {
    display: block;
    margin: 0 auto;
  }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let keys = {};
let bullets = [];
let enemies = [];
let particles = [];
let powerups = [];
let score = 0;
let gameOver = false;

const ship = {
  x: canvas.width / 2,
  y: canvas.height - 100,
  size: 20,
  speed: 6,
  color: '#4af',
  angle: 0
};

class Bullet {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.speed = 10;
  }
  update() {
    this.y -= this.speed;
  }
  draw() {
    ctx.fillStyle = '#4af';
    ctx.fillRect(this.x - 2, this.y, 4, 10);
  }
}

class Enemy {
  constructor() {
    this.x = Math.random() * canvas.width;
    this.y = -20;
    this.size = 20 + Math.random() * 20;
    this.speed = 2 + Math.random() * 2;
    this.color = '#f44';
  }
  update() {
    this.y += this.speed;
  }
  draw() {
    ctx.beginPath();
    ctx.strokeStyle = this.color;
    ctx.lineWidth = 2;
    ctx.rect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);
    ctx.stroke();
  }
}

class Particle {
  constructor(x, y, color) {
    this.x = x;
    this.y = y;
    this.dx = (Math.random() - 0.5) * 4;
    this.dy = (Math.random() - 0.5) * 4;
    this.life = 60;
    this.color = color;
  }
  update() {
    this.x += this.dx;
    this.y += this.dy;
    this.life--;
  }
  draw() {
    ctx.fillStyle = this.color + Math.floor(this.life / 6).toString(16);
    ctx.fillRect(this.x, this.y, 3, 3);
  }
}

class PowerUp {
  constructor(x, y, type) {
    this.x = x;
    this.y = y;
    this.type = type;
    this.size = 15;
    this.dy = 2;
    this.color = type === 'shield' ? '#0f0' : (type === 'rapid' ? '#ff0' : '#0ff');
  }
  update() {
    this.y += this.dy;
  }
  draw() {
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.strokeStyle = this.color;
    ctx.lineWidth = 2;
    ctx.stroke();
  }
}

function drawShip() {
  ctx.save();
  ctx.translate(ship.x, ship.y);
  ctx.rotate(ship.angle);
  ctx.beginPath();
  ctx.moveTo(0, -ship.size);
  ctx.lineTo(ship.size / 2, ship.size);
  ctx.lineTo(-ship.size / 2, ship.size);
  ctx.closePath();
  ctx.fillStyle = ship.color;
  ctx.shadowColor = ship.color;
  ctx.shadowBlur = 20;
  ctx.fill();
  ctx.restore();
}

function handleParticles() {
  particles.forEach((p, i) => {
    p.update();
    p.draw();
    if (p.life <= 0) particles.splice(i, 1);
  });
}

function spawnEnemy() {
  if (Math.random() < 0.02) enemies.push(new Enemy());
}

function spawnPowerUp(x, y) {
  if (Math.random() < 0.2) {
    const types = ['shield', 'rapid', 'slow'];
    const type = types[Math.floor(Math.random() * types.length)];
    powerups.push(new PowerUp(x, y, type));
  }
}

function update() {
  if (gameOver) return;

  ctx.fillStyle = 'rgba(10,20,40,0.3)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  drawShip();

  bullets.forEach((b, bi) => {
    b.update();
    b.draw();
    if (b.y < 0) bullets.splice(bi, 1);
  });

  enemies.forEach((e, ei) => {
    e.update();
    e.draw();

    if (e.y > canvas.height) enemies.splice(ei, 1);

    bullets.forEach((b, bi) => {
      if (Math.abs(b.x - e.x) < e.size / 2 && Math.abs(b.y - e.y) < e.size / 2) {
        for (let i = 0; i < 10; i++) particles.push(new Particle(e.x, e.y, e.color));
        spawnPowerUp(e.x, e.y);
        enemies.splice(ei, 1);
        bullets.splice(bi, 1);
        score += 10;
      }
    });

    if (Math.abs(ship.x - e.x) < e.size && Math.abs(ship.y - e.y) < e.size) {
      gameOver = true;
    }
  });

  powerups.forEach((p, pi) => {
    p.update();
    p.draw();
    if (Math.abs(ship.x - p.x) < p.size && Math.abs(ship.y - p.y) < p.size) {
      powerups.splice(pi, 1);
      for (let i = 0; i < 10; i++) particles.push(new Particle(p.x, p.y, p.color));
    }
  });

  handleParticles();
  spawnEnemy();

  ctx.fillStyle = '#fff';
  ctx.font = '20px monospace';
  ctx.fillText('Score: ' + score, 20, 30);

  if (gameOver) {
    ctx.fillStyle = '#f44';
    ctx.font = '50px monospace';
    ctx.fillText('GAME OVER', canvas.width / 2 - 150, canvas.height / 2);
    ctx.font = '25px monospace';
    ctx.fillText('Press R to Restart', canvas.width / 2 - 120, canvas.height / 2 + 50);
  }

  requestAnimationFrame(update);
}

document.addEventListener('keydown', (e) => {
  keys[e.code] = true;
  if (e.code === 'Space' && !gameOver) bullets.push(new Bullet(ship.x, ship.y - ship.size));
  if (e.code === 'KeyR' && gameOver) {
    enemies = [];
    bullets = [];
    particles = [];
    powerups = [];
    score = 0;
    gameOver = false;
    ship.x = canvas.width / 2;
  }
});

document.addEventListener('keyup', (e) => keys[e.code] = false);

function moveShip() {
  if (keys['ArrowLeft'] && ship.x > 20) ship.x -= ship.speed;
  if (keys['ArrowRight'] && ship.x < canvas.width - 20) ship.x += ship.speed;
}

function loop() {
  moveShip();
  if (!gameOver) requestAnimationFrame(loop);
}

loop();
update();
</script>
</body>
</html>
